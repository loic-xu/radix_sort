


Comparaison avec k = 3

```{r}
################################################
############# Setup & Données ##################
################################################

# Définir différentes tailles de n pour tester
vector_n <- seq(100, 50100, by = 5000)  # Tester de 100 à 50000 avec un pas de 5000
k <- 3  # Exemple de nombre de chiffres (k = 3 : valeurs entre 100 et 999)

# Types de données à tester
datasets <- c("random", "sorted", "reverse_sorted", "sorted_90")

# Fonction qui génère des nombres selon le nombre de chiffres (k)
generate_values <- function(n, k) {
  min_value <- 1  # Le minimum possible pour k chiffres (par exemple, 100 pour k=3)
  max_value <- 10^k - 1  # Le maximum possible pour k chiffres (par exemple, 999 pour k=3)
  return(sample(min_value:max_value, n, replace = TRUE))  # Génère des valeurs entre min_value et max_value
}

# Fonction qui mesure le temps d'exécution des algorithmes Rcpp de tri
one.simu_rcpp <- function(n, type = "random", func = "quick_sort_Rcpp") {
  
  # Génération des datasets selon l'intervalle défini par k
  if (type == "random") {
    v <- generate_values(n, k)  # Valeurs avec n éléments et k chiffres
  } else if (type == "sorted") {
    v <- sort(generate_values(n, k))  # Triées croissantes
  } else if (type == "reverse_sorted") {
    v <- sort(generate_values(n, k), decreasing = TRUE)  # Triées décroissantes
  } else if (type == "sorted_90") {
    # Générer 90% triées et 10% aléatoires
    sorted_part <- sort(generate_values(0.9 * n, k))  # 90% triées
    random_part <- generate_values(0.1 * n, k)  # 10% aléatoires
    v <- c(sorted_part, random_part)
  }
  
  # Appel des fonctions de tri
  if (func == "quick_sort_Rcpp") t <- system.time(quick_sort_Rcpp(v))[[1]]
  if (func == "radix_sort_Rcpp") t <- system.time(radix_sort_Rcpp(v))[[1]]
  
  return(t)
}

################################################################################################

###########################################################
############# Simulation à taille variable ##################
###########################################################

nbSimus <- length(vector_n)  # Le nombre de tailles de données testées

# Initialiser une liste pour stocker les résultats
results_list <- list()

# Simulations pour chaque type de dataset
for (dataset in datasets) {
  # Init des vecteurs pour stocker les temps
  time1 <- numeric(nbSimus)
  time2 <- numeric(nbSimus)
  
  # Simulations pour chaque taille de n
  for (i in 1:nbSimus) {
    # Calculer la médiane des temps pour chaque algorithme sur chaque taille de n
    time1[i] <- median(replicate(10, one.simu_rcpp(vector_n[i], type = dataset, func = "quick_sort_Rcpp")))
    time2[i] <- median(replicate(10, one.simu_rcpp(vector_n[i], type = dataset, func = "radix_sort_Rcpp")))
  }
  
  # Stocker les résultats dans une liste
  results_list[[dataset]] <- data.frame(
    n = vector_n,
    quick_Rcpp = time1,
    base_Rcpp = time2
  )
}

# Packages
library(ggplot2)
library(tidyr)

# Transformer les résultats en format long (liste par dataset)
df_long_list <- lapply(names(results_list), function(dataset) {
  df <- results_list[[dataset]]
  df$dataset <- dataset
  pivot_longer(df, cols = -c(n, dataset), names_to = "algo", values_to = "temps")
})

# Afficher chaque graphique dans une fenêtre séparée
for (df_long in df_long_list) {
  dataset_name <- unique(df_long$dataset)
  
  # Plot
  print(
    ggplot(df_long, aes(x = n, y = temps, color = algo)) +
      geom_line(linewidth = 1) +
      labs(title = paste("Comparaison Rcpp -", dataset_name),
           x = "Taille des données",
           y = "Temps (s)") +
      theme_minimal() +
      theme(legend.position = "bottom")
  )
}


```


```{r}
one.simu <- function(n, func) {
  # Génère un vecteur aléatoire
  vec <- sample(1:(10 * n), n, replace = TRUE)
  
  # Récupère la fonction à exécuter
  f <- if (is.character(func)) match.fun(func) else func
  
  # Mesure du temps d’exécution
  time <- system.time(f(vec))["elapsed"]
  return(time)
}


# Définir le nombre de simulations et la taille des données
nbSimus <- 10  # Le nombre de simulations
vector_n <- seq(from = 100, to = 50100, length.out = nbSimus)

# Tri Base Rcpp
res_base <- data.frame(matrix(0, nbSimus, 2))
colnames(res_base) <- c("n", "Time")
for (j in 1:nbSimus) {
  n_val <- vector_n[j]
  res_base[j,] <- c(n_val, one.simu(n_val, func = "radix_sort_Rcpp"))
}

# Init pour R
res_base_R <- data.frame(matrix(0, nbSimus, 2))
colnames(res_base_R) <- c("n", "Time")

# Boucle pour R
for (j in 1:nbSimus) {
  n_val <- vector_n[j]
  res_base_R[j,] <- c(n_val, one.simu(n_val, func = "radix_sort"))
}

# Création du dataframe de comparaison avec les résultats
df_compar <- data.frame(
  n = vector_n,
  base_R = res_base_R$Time,
  base_Rcpp = res_base$Time
)

# Transformation des résultats en format long pour ggplot
library(tidyr)
df_long <- pivot_longer(df_compar, cols = -n, names_to = "algo", values_to = "temps")

# Comparaison pour l'algorithme de tri base
df_base <- data.frame(
  n = vector_n,
  base_R = res_base_R$Time,
  base_Rcpp = res_base$Time
)
df_base_long <- pivot_longer(df_base, cols = -n, names_to = "algo", values_to = "temps")

library(ggplot2)
ggplot(df_base_long, aes(x = n, y = temps, color = algo)) +
  geom_line(size = 1) +
  labs(title = "Comparaison R vs Rcpp - Tri Base",
       x = "Taille des données", y = "Temps (s)") +
  theme_minimal()

# Calcul du ratio des temps R / Rcpp pour l'algorithme radix_sort
df_compar_ratio <- data.frame(
  n = vector_n,
  base_R_vs_Rcpp = res_base_R$Time / res_base$Time
)

# Affichage des ratios
print("Comparaison des ratios Time_R / Time_Rcpp pour l'algorithme Tri Base:")
print(df_compar_ratio)


```
